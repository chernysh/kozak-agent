# Roadmap: Kozak Agent

Агент працює локально на сервері, збирає метрики/перевірки та відправляє їх у моніторинг по WebSocket. Нижче — послідовні кроки для розробника.

---

## 1. Інфраструктура (зроблено)

- [x] Docker Compose: сервіси `agent` та `mock-monitoring`.
- [x] Фейковий моніторинг: WebSocket-сервер на порту 8765, логує всі вхідні повідомлення в консоль.
- [x] Агент: структура проєкту, конфіг з `.env`, базовий цикл перевірок та відправка в моніторинг.
- [x] Авторелад агента при зміні `.py` файлів у контейнері (watchdog).

**Що перевірити:** `docker compose up` — у консолі mock-monitoring мають з’являтися події від агента.

---

## 2. Модуль SSH (частково зроблено)

- [x] Конфігурація з env: `SSH_HOST`, `SSH_PORT`, `SSH_USER`, `SSH_KEY_PATH` або `SSH_PASSWORD`.
- [x] Перевірка з’єднання через paramiko у executor (щоб не блокувати asyncio).
- [ ] **Задача:** Додати опційну перевірку доступності порту (TCP) перед SSH (наприклад, через `asyncio.open_connection`), щоб розрізняти "порт закритий" і "невірні креденшали".
- [ ] **Задача:** Логувати час виконання перевірки в `details.duration_ms` та відправляти в моніторинг.

**Деталі реалізації:** Залишити paramiko в `run_in_executor`; перед ним можна зробити швидкий `asyncio.wait_for(asyncio.open_connection(host, port), timeout=5)`.

---

## 3. Модуль Postgres

- [ ] **Задача:** Реалізувати підключення до PostgreSQL за конфігом з env (`POSTGRES_*`).
- [ ] **Задача:** Використати бібліотеку `asyncpg`: підключення, виконання `SELECT 1`, закриття. Повертати `CheckResult` зі статусом ok/error.
- [ ] **Задача:** Опційно: збирати базові метрики (наприклад, кількість з’єднань з `pg_stat_activity` або розмір БД) і відправляти в `details` для моніторингу.
- [ ] Зареєструвати модуль у `ENABLED_MODULES` та протестувати через mock-monitoring.

**Деталі реалізації:** Один виклик `asyncpg.connect()` з параметрами з `config`, потім `conn.fetchval("SELECT 1")`. Обгорнути в try/except, у разі помилки — `CheckResult(status="error", message=...)`.

---

## 4. Модуль MySQL

- [ ] **Задача:** Реалізувати підключення до MySQL/MariaDB за env (`MYSQL_*`).
- [ ] **Задача:** Використати асинхронний драйвер, наприклад `aiomysql`: підключення, `SELECT 1`, закриття. Аналогічно Postgres — повертати `CheckResult`.
- [ ] **Задача:** Опційно: метрики (наприклад, статус змінних або список процесів) у `details`.
- [ ] Додати модуль у конфіг та перевірити через mock-monitoring.

**Деталі реалізації:** `async with aiomysql.create_pool(...)` або одне підключення, виконання простого запиту, обробка помилок.

---

## 5. Модуль Nginx

- [ ] **Задача:** Реалізувати перевірку за URL статусу (`NGINX_STATUS_URL`). Зробити GET-запит (наприклад, `aiohttp` або `httpx`).
- [ ] **Задача:** Перевіряти HTTP статус 200 та опційно парсити текст стану (якщо це stub_status). Відправляти в моніторинг `CheckResult` з `details` (наприклад, parsed metrics).
- [ ] **Задача:** Обробляти таймаут та недоступність хоста; не падати при невалідній відповіді — повертати error з зрозумілим повідомленням.

**Деталі реалізації:** `async with aiohttp.ClientSession() as s: async with s.get(url, timeout=...) as r: ...`. Для парсингу stub_status можна використати простий regex або split по рядках.

---

## 6. Інші важливі служби (systemd / порти)

- [ ] **Задача:** Визначити список служб для перевірки (наприклад, з env `SYSTEMD_SERVICES=nginx,postgresql`). На лінукс-хостах перевіряти через `systemctl is-active <unit>` (виклик у executor або subprocess).
- [ ] **Задача:** Альтернатива: перевірка доступності портів (TCP) для заданих пар host:port з конфігу. Реалізувати один модуль "ports" або "tcp" з конфігом типу `TCP_CHECKS=localhost:80,localhost:443`.
- [ ] Відправляти результати по кожній службі/порту в моніторинг (окремі події або один агрегований — визначити формат).

**Деталі реалізації:** Для systemd — `subprocess.run(["systemctl", "is-active", unit], capture_output=True, timeout=5)`. Для портів — `asyncio.open_connection(host, port)` з таймаутом.

---

## 7. Надійність та повторні спроби

- [ ] **Задача:** При недоступності моніторингу (WebSocket не підключається) не втрачати події: додати чергу (наприклад, `asyncio.Queue`) з обмеженим розміром. Фонова задача забирає з черги та відправляє; при помилці — повторна спроба з backoff (наприклад, 1s, 2s, 4s) або повтор через N секунд.
- [ ] **Задача:** Визначити політику при переповненні черги (відкидати старі або нові події, логувати).
- [ ] **Задача:** При старті агента спробувати одразу підключитися до моніторингу і залогувати результат; при невдачі — продовжувати роботу з чергою.

**Деталі реалізації:** Винести відправку з `client.push_to_monitoring` у окрему задачу `push_events_loop(queue)`. Модулі кладуть події в `queue.put_nowait(payload)`. При помилці WebSocket — `await asyncio.sleep(backoff)` і повтор.

---

## 8. Безпека та конфігурація

- [ ] **Задача:** Не логувати та не відправляти в моніторинг паролі/API ключі. Перевірити, щоб у `details` та логах не потрапляли секрети.
- [ ] **Задача:** Підтримка кількох env-файлів (наприклад, `.env` і `.env.local`) або явний шлях до конфігу через змінну `AGENT_ENV_FILE`.
- [ ] **Задача:** Валідація обов’язкових змінних при старті: якщо увімкнено модуль `postgres`, перевіряти наявність `POSTGRES_HOST` тощо; при відсутності — лог і пропуск модуля або вихід з помилкою.

---

## 9. Формат повідомлень до моніторингу

- [ ] **Задача:** Зафіксувати єдиний формат payload для моніторингу: тип події (`check`, `metric`, `heartbeat`?), обов’язкові поля (`timestamp`, `module`, `status`), опційні (`details`, `metrics`). Додати короткий опис у README або окремому `PROTOCOL.md`.
- [ ] **Задача:** Опційно: heartbeat — періодична подія "агент живий" (окремий інтервал), щоб моніторинг міг виявляти "немає даних".

---

## 10. Тести та якість коду

- [ ] **Задача:** Юніт-тести для модулів: моки для з’єднань (SSH, DB, HTTP), перевірка формування `CheckResult` та payload.
- [ ] **Задача:** Інтеграційний тест: запуск агента з mock-monitoring, перевірка, що події потрапляють у WebSocket (наприклад, тестовий клієнт підключається до mock і перевіряє отримані повідомлення).
- [ ] **Задача:** Лінтер (ruff або flake8) та форматування (black) у CI або pre-commit.

---

## Порядок виконання (рекомендований)

1. Пункти 2–5: доробити SSH, реалізувати Postgres, MySQL, Nginx.
2. Пункт 6: systemd або перевірка портів.
3. Пункт 7: черга та повторні спроби відправки.
4. Пункти 8–9: безпека, формат протоколу, heartbeat.
5. Пункт 10: тести та лінтери.

Можна паралельно вести пункти 2–6 по різних модулях.
